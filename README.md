Before I describe the app, I would like to state that I have made the following assumption about the Fibonacci sequence: The 1st number in the Fibonacci sequence is 0. That is, there is no 0th position. So the sequence will be 0,1, 1, 2, 3, 5, 8…….Infinity.  Some people believe that 0 is actually at the 0th position. However, I have not made that assumption for the purpose of this assignment. 
In order to solve this assignment, I created two separate apps. They are both build in .NET Core. One of the apps is simply an API service with one API. The name of the app is NFibonacci.  The API accepts a position and returns the Fibonacci number at that position. The app was built using ASP.NET Core Web API and is hosted on Microsoft Azure.  The URL for the API is the following : 
https://nfibonacci20230125232018.azurewebsites.net
The other app is called the FibonacciAppMVC. This app presents a frontend client which users can use to get a Fibonacci number at a position. The client also displays a list of past searches. Whenever a user enters a number to get the corresponding Fibonacci number, the app calls the NFibonacci API service described above to get the Fibonacci number. Additionally, the app also saves the search to its database. The app can be accessed using the following URL:
https://fibonacciappmvclatestrg.azurewebsites.net
Please note that when you initially go to the homepage of the app, it may take a few seconds for the search history table to be populated. The reason is that I am populating the table asynchronously. Also, you may notice in the code that I am repopulating the search table every time a user searches for a Fibonacci number. I could have simply appended the new number to the table. However, that would have missed the new searches if multiple users are using the app. 
In the MVC app, I have created two different services, FibAPIConsunerService and SearchHistoryService. The FibAPIConsumer service calls the NFibonacci API to get the Fibonacci number. The SearchHistory service gets the search history from the database and also adds new search records. The pattern I followed is akin to the repository pattern. The advantage of using this is that there is no database access code in the controller method which not only enhances code reusability but also makes code maintenance a lot easier. 
The reason I created a separate API service from the MVC app is also for reusability. For example, in case other apps need similar functionality, they could use the existing API service. 


